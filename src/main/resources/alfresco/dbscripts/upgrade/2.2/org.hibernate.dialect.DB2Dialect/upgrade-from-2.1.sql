--
-- Title:      Apply schema modifications to upgrade from 2.1.a 
-- Database:   DB2
-- Since:      V2.1.a Schema 81
-- Author:     
--
-- In order to streamline the upgrade, all modifications to large tables need to
-- be handled in as few steps as possible.  This usually involves as few ALTER TABLE
-- statements as possible.  The general approach is:
--   Create a table with the correct structure, including indexes and CONSTRAINTs
--   Copy pristine data into the new table
--   Drop the old table
--   Rename the new table
--
-- Please contact support@alfresco.com if you need assistance with the upgrade.
--

-- -------------------------------
-- Build Namespaces and QNames --
-- -------------------------------

CREATE TABLE ALF_NAMESPACE ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY, 
    VERSION BIGINT NOT NULL, 
    URI VARCHAR(100) NOT NULL, 
    PRIMARY KEY (ID), 
    UNIQUE (URI) 
);

CREATE TABLE ALF_QNAME ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY, 
    VERSION BIGINT NOT NULL, 
    NS_ID BIGINT NOT NULL, 
    LOCAL_NAME VARCHAR(200) NOT NULL, 
    PRIMARY KEY (ID), 
    UNIQUE (NS_ID, LOCAL_NAME) 
);
create index fk_alf_qname_ns on ALF_QNAME (ns_id);
alter table alf_qname add constraint fk_alf_qname_ns foreign key (ns_id) references alf_namespace;

-- Create temporary table to hold static QNames
CREATE TABLE T_QNAMES ( 
    QNAME VARCHAR(255) NOT NULL, 
    NAMESPACE VARCHAR(100), 
    LOCALNAME VARCHAR(200),  
    QNAME_ID BIGINT 
);
CREATE INDEX TIDX_TQN_QN ON T_QNAMES (QNAME);
CREATE INDEX TIDX_TQN_NS ON T_QNAMES (NAMESPACE);
CREATE INDEX TIDX_TQN_LN ON T_QNAMES (LOCALNAME);

-- Populate the table with all known static QNames
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.TYPE_QNAME FROM ALF_NODE S LEFT OUTER JOIN T_QNAMES T ON (S.TYPE_QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.QNAME FROM ALF_NODE_ASPECTS S LEFT OUTER JOIN T_QNAMES T ON (S.QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.QNAME FROM ALF_NODE_PROPERTIES S LEFT OUTER JOIN T_QNAMES T ON (S.QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.QNAME FROM AVM_ASPECTS S LEFT OUTER JOIN T_QNAMES T ON (S.QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.NAME FROM AVM_ASPECTS_NEW S LEFT OUTER JOIN T_QNAMES T ON (S.NAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.QNAME FROM AVM_NODE_PROPERTIES S LEFT OUTER JOIN T_QNAMES T ON (S.QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.QNAME FROM AVM_NODE_PROPERTIES_NEW S LEFT OUTER JOIN T_QNAMES T ON (S.QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.QNAME FROM AVM_STORE_PROPERTIES S LEFT OUTER JOIN T_QNAMES T ON (S.QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.TYPE_QNAME FROM ALF_NODE_ASSOC S LEFT OUTER JOIN T_QNAMES T ON (S.TYPE_QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.TYPE_QNAME FROM ALF_CHILD_ASSOC S LEFT OUTER JOIN T_QNAMES T ON (S.TYPE_QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.TYPE_QNAME FROM ALF_PERMISSION S LEFT OUTER JOIN T_QNAMES T ON (S.TYPE_QNAME = T.QNAME) WHERE T.QNAME IS NULL );

-- Extract the namespace and localnames from the QNames
UPDATE T_QNAMES SET NAMESPACE = CONCAT ('FILLER-', SUBSTR(QNAME, 2, POSSTR(QNAME, '}') - 2));
UPDATE T_QNAMES SET LOCALNAME = SUBSTR(QNAME, POSSTR(QNAME, '}') + 1);

-- Move the Namespaces to their new home
INSERT INTO ALF_NAMESPACE (URI, VERSION) ( SELECT DISTINCT(X.NAMESPACE), 1 FROM ( SELECT T.NAMESPACE, N.URI FROM T_QNAMES T LEFT OUTER JOIN ALF_NAMESPACE N ON (N.URI = T.NAMESPACE) ) X  WHERE  X.URI IS NULL );

-- Move the Localnames to their new home
INSERT INTO ALF_QNAME (NS_ID, LOCAL_NAME, VERSION) ( SELECT X.NS_ID, X.T_LOCALNAME, 1 FROM ( SELECT N.ID AS NS_ID, T.LOCALNAME AS T_LOCALNAME, Q.LOCAL_NAME AS Q_LOCALNAME  FROM T_QNAMES T JOIN ALF_NAMESPACE N ON (N.URI = T.NAMESPACE) LEFT OUTER JOIN ALF_QNAME Q ON (Q.LOCAL_NAME = T.LOCALNAME) ) X WHERE Q_LOCALNAME IS NULL GROUP BY X.NS_ID, X.T_LOCALNAME );

-- Record the new qname IDs
UPDATE T_QNAMES T SET T.QNAME_ID = ( SELECT Q.ID FROM ALF_QNAME Q JOIN ALF_NAMESPACE NS ON (Q.NS_ID = NS.ID)  WHERE NS.URI = T.NAMESPACE AND Q.LOCAL_NAME = T.LOCALNAME );

-- Create temporary table for dynamic (child) QNames
CREATE TABLE T_QNAMES_DYN ( 
    QNAME VARCHAR(255) NOT NULL, 
    NAMESPACE VARCHAR(100), 
    NAMESPACE_ID BIGINT, 
    LOCAL_NAME VARCHAR(255)
);
CREATE INDEX TIDX_QND_QN ON T_QNAMES_DYN (QNAME);
CREATE INDEX TIDX_QND_NS ON T_QNAMES_DYN (NAMESPACE);

-- Populate the table with the child association paths
INSERT INTO T_QNAMES_DYN (QNAME) (  SELECT DISTINCT(QNAME) FROM ALF_CHILD_ASSOC );

-- Extract the Namespace
UPDATE T_QNAMES_DYN SET NAMESPACE = CONCAT ('FILLER-', SUBSTR(QNAME, 2, POSSTR(QNAME, '}') - 2));

-- Extract the Localname
UPDATE T_QNAMES_DYN SET LOCAL_NAME = SUBSTR(QNAME, POSSTR(QNAME, '}') + 1);

-- Move the namespaces to the their new home
INSERT INTO ALF_NAMESPACE (URI, VERSION)( SELECT DISTINCT(X.NAMESPACE), 1 FROM ( SELECT T.NAMESPACE, N.URI FROM T_QNAMES_DYN T LEFT OUTER JOIN ALF_NAMESPACE N ON (N.URI = T.NAMESPACE) ) X WHERE X.URI IS NULL );

-- Record the new namespace IDs
UPDATE T_QNAMES_DYN T SET T.NAMESPACE_ID = (SELECT NS.ID FROM ALF_NAMESPACE NS WHERE NS.URI = T.NAMESPACE);

-- This is a small table so we change it in place
ALTER TABLE ALF_PERMISSION ADD COLUMN TYPE_QNAME_ID BIGINT;
UPDATE ALF_PERMISSION AS P SET P.TYPE_QNAME_ID = ( SELECT Q.ID FROM ALF_QNAME AS Q JOIN ALF_NAMESPACE NS ON (Q.NS_ID = NS.ID) WHERE CONCAT(CONCAT('{', SUBSTR(NS.URI, 8)), CONCAT('}', Q.LOCAL_NAME)) = P.TYPE_QNAME);

--ASSIGN:ap_max_id=next_val
select case when max(id) is not null then max(id)+1 else 1 end as next_val from ALF_PERMISSION;

CREATE TABLE T_ALF_PERMISSION (ID BIGINT GENERATED BY DEFAULT AS IDENTITY (start with ${ap_max_id}), 
    VERSION BIGINT NOT NULL, 
    NAME VARCHAR(100) NOT NULL, 
    TYPE_QNAME_ID BIGINT NOT NULL, 
    PRIMARY KEY (ID)
);

INSERT INTO T_ALF_PERMISSION (ID, VERSION, NAME, TYPE_QNAME_ID) ( SELECT ID, VERSION, NAME, TYPE_QNAME_ID FROM ALF_PERMISSION );
DROP TABLE ALF_PERMISSION;
RENAME T_ALF_PERMISSION TO ALF_PERMISSION;
ALTER TABLE ALF_PERMISSION ADD CONSTRAINT ALF_PERM_UNIQUE UNIQUE (TYPE_QNAME_ID, NAME);
CREATE INDEX FK_ALF_PERM_TQN ON ALF_PERMISSION (TYPE_QNAME_ID);
ALTER TABLE ALF_PERMISSION ADD CONSTRAINT FK_ALF_PERM_TQN FOREIGN KEY (TYPE_QNAME_ID) REFERENCES ALF_QNAME (ID);
alter table alf_access_control_entry add constraint fk_alf_ace_perm foreign key (permission_id) references alf_permission;

-- -------------------
-- Build new Store --
-- -------------------
CREATE TABLE T_ALF_STORE ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY, 
    VERSION BIGINT NOT NULL, 
    PROTOCOL VARCHAR(50) NOT NULL, 
    IDENTIFIER VARCHAR(100) NOT NULL, 
    ROOT_NODE_ID BIGINT, 
    PRIMARY KEY (ID), 
    UNIQUE (PROTOCOL, IDENTIFIER) 
);

-- --------------------------
-- Populate the ADM nodes --
-- --------------------------
--ASSIGN:an_max_id=next_val
select case when max(id) is not null then max(id)+1 else 1 end as next_val from ALF_NODE;

CREATE TABLE T_ALF_NODE ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY (start with ${an_max_id}), 
    VERSION BIGINT NOT NULL, 
    STORE_ID BIGINT NOT NULL, 
    UUID VARCHAR(36) NOT NULL, 
    TRANSACTION_ID BIGINT NOT NULL, 
    NODE_DELETED SMALLINT NOT NULL, 
    TYPE_QNAME_ID BIGINT NOT NULL, 
    ACL_ID BIGINT, 
    AUDIT_CREATOR VARCHAR(255), 
    AUDIT_CREATED VARCHAR(30), 
    AUDIT_MODIFIER VARCHAR(255), 
    AUDIT_MODIFIED VARCHAR(30), 
    AUDIT_ACCESSED VARCHAR(30), 
    PRIMARY KEY (ID), 
    UNIQUE (STORE_ID, UUID) 
);
CREATE INDEX FK_ALF_NODE_ACL ON T_ALF_NODE (ACL_ID);
CREATE INDEX FK_ALF_NODE_STORE ON T_ALF_NODE (STORE_ID);
CREATE INDEX FK_ALF_NODE_TQN ON T_ALF_NODE (TYPE_QNAME_ID);
CREATE INDEX FK_ALF_NODE_TXN ON T_ALF_NODE (TRANSACTION_ID);
CREATE INDEX IDX_ALF_NODE_DEL ON T_ALF_NODE (NODE_DELETED);

-- Fill the store table
INSERT INTO T_ALF_STORE (VERSION, PROTOCOL, IDENTIFIER, ROOT_NODE_ID) (SELECT 1, STORE.PROTOCOL, STORE.IDENTIFIER, STORE.ROOT_NODE_ID FROM ALF_STORE STORE);

DROP TABLE ALF_STORE;
RENAME T_ALF_STORE TO ALF_STORE;

-- Summarize the alf_node_status table
CREATE TABLE T_SUMMARY_NSTAT ( 
    NODE_ID BIGINT NOT NULL, 
    TRANSACTION_ID BIGINT DEFAULT NULL,  
    PRIMARY KEY (NODE_ID) 
);
INSERT INTO T_SUMMARY_NSTAT (NODE_ID, TRANSACTION_ID) SELECT NODE_ID, TRANSACTION_ID FROM ALF_NODE_STATUS WHERE NODE_ID IS NOT NULL;

INSERT INTO T_ALF_NODE(ID, VERSION, STORE_ID, UUID, TRANSACTION_ID, NODE_DELETED, TYPE_QNAME_ID, ACL_ID) SELECT N.ID, 1, S.ID, N.UUID, NSTAT.TRANSACTION_ID, 0, Q.QNAME_ID, N.ACL_ID FROM ALF_NODE AS N JOIN T_QNAMES AS Q ON (Q.QNAME = N.TYPE_QNAME) JOIN T_SUMMARY_NSTAT AS NSTAT ON (NSTAT.NODE_ID = N.ID) JOIN ALF_STORE AS S ON (S.PROTOCOL = N.PROTOCOL AND S.IDENTIFIER = N.IDENTIFIER);
DROP TABLE T_SUMMARY_NSTAT;

-- Hook the store up to the root node
CREATE INDEX FK_ALF_STORE_ROOT ON ALF_STORE (ROOT_NODE_ID);

-- -----------------------------
-- Populate Version Counter  --
-- -----------------------------
CREATE TABLE T_ALF_VERSION_COUNT ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY, 
    VERSION BIGINT NOT NULL, 
    STORE_ID BIGINT NOT NULL UNIQUE, 
    VERSION_COUNT INTEGER NOT NULL, 
    PRIMARY KEY (ID) 
);
CREATE INDEX FK_ALF_VC_STORE ON T_ALF_VERSION_COUNT (STORE_ID);

INSERT INTO T_ALF_VERSION_COUNT ( VERSION, STORE_ID, VERSION_COUNT ) SELECT 1, S.ID, VC.VERSION_COUNT FROM ALF_VERSION_COUNT AS VC JOIN ALF_STORE AS S ON (S.PROTOCOL = VC.PROTOCOL AND S.IDENTIFIER = VC.IDENTIFIER);

DROP TABLE ALF_VERSION_COUNT;
RENAME T_ALF_VERSION_COUNT TO ALF_VERSION_COUNT;
ALTER TABLE ALF_VERSION_COUNT ADD CONSTRAINT FK_ALF_VC_STORE FOREIGN KEY (STORE_ID) REFERENCES ALF_STORE;

-- -----------------------------
-- Populate the Child Assocs --
-- -----------------------------
--ASSIGN:aca_max_id=next_val
select case when max(id) is not null then max(id)+1 else 1 end as next_val from ALF_CHILD_ASSOC;

CREATE TABLE T_ALF_CHILD_ASSOC ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY (start with ${aca_max_id}), 
    VERSION BIGINT NOT NULL, 
    PARENT_NODE_ID BIGINT NOT NULL, 
    TYPE_QNAME_ID BIGINT NOT NULL, 
    CHILD_NODE_NAME_CRC BIGINT NOT NULL, 
    CHILD_NODE_NAME VARCHAR(50) NOT NULL, 
    CHILD_NODE_ID BIGINT NOT NULL, 
    QNAME_NS_ID BIGINT NOT NULL, 
    QNAME_LOCALNAME VARCHAR(255) NOT NULL, 
    IS_PRIMARY SMALLINT, 
    ASSOC_INDEX INTEGER, 
    PRIMARY KEY (ID), 
    UNIQUE (PARENT_NODE_ID, TYPE_QNAME_ID, CHILD_NODE_NAME_CRC, CHILD_NODE_NAME) 
);
CREATE INDEX FK_ALF_CASS_CNODE ON T_ALF_CHILD_ASSOC (CHILD_NODE_ID);
CREATE INDEX FK_ALF_CASS_PNODE ON T_ALF_CHILD_ASSOC (PARENT_NODE_ID);
CREATE INDEX FK_ALF_CASS_QNNS ON T_ALF_CHILD_ASSOC (QNAME_NS_ID);
CREATE INDEX FK_ALF_CASS_TQN ON T_ALF_CHILD_ASSOC (TYPE_QNAME_ID);
CREATE INDEX IDX_ALF_CASS_QNLN ON T_ALF_CHILD_ASSOC (QNAME_LOCALNAME);
CREATE INDEX IDX_ALF_CASS_PRI ON T_ALF_CHILD_ASSOC (PARENT_NODE_ID, IS_PRIMARY, CHILD_NODE_ID);

INSERT INTO T_ALF_CHILD_ASSOC( ID, VERSION, PARENT_NODE_ID, TYPE_QNAME_ID, CHILD_NODE_NAME_CRC, CHILD_NODE_NAME, CHILD_NODE_ID, QNAME_NS_ID, QNAME_LOCALNAME, IS_PRIMARY, ASSOC_INDEX ) SELECT CA.ID, 1, CA.PARENT_NODE_ID, TQN.QNAME_ID, CA.CHILD_NODE_NAME_CRC, CA.CHILD_NODE_NAME,      CA.CHILD_NODE_ID, TQNDYN.NAMESPACE_ID, TQNDYN.LOCAL_NAME, CA.IS_PRIMARY, CA.ASSOC_INDEX FROM ALF_CHILD_ASSOC CA JOIN T_QNAMES_DYN TQNDYN ON (CA.QNAME = TQNDYN.QNAME) JOIN T_QNAMES TQN ON (CA.TYPE_QNAME = TQN.QNAME);
-- Clean up
DROP TABLE T_QNAMES_DYN;
DROP TABLE ALF_CHILD_ASSOC;
RENAME T_ALF_CHILD_ASSOC TO ALF_CHILD_ASSOC;
ALTER TABLE ALF_CHILD_ASSOC ADD CONSTRAINT FK_ALF_CASS_QNNS FOREIGN KEY (QNAME_NS_ID) REFERENCES ALF_NAMESPACE (ID);
ALTER TABLE ALF_CHILD_ASSOC ADD CONSTRAINT FK_ALF_CASS_TQN FOREIGN KEY (TYPE_QNAME_ID) REFERENCES ALF_QNAME (ID);

-- ----------------------------
-- Populate the Node Assocs --
-- ----------------------------
--ASSIGN:ana_max_id=next_val
select case when max(id) is not null then max(id)+1 else 1 end as next_val from ALF_NODE_ASSOC;

CREATE TABLE T_ALF_NODE_ASSOC ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY (start with ${ana_max_id}), 
    VERSION BIGINT NOT NULL, 
    SOURCE_NODE_ID BIGINT NOT NULL, 
    TARGET_NODE_ID BIGINT NOT NULL, 
    TYPE_QNAME_ID BIGINT NOT NULL, 
    PRIMARY KEY (ID), 
    UNIQUE (SOURCE_NODE_ID, TARGET_NODE_ID, TYPE_QNAME_ID) 
);
CREATE INDEX FK_ALF_NASS_SNODE ON T_ALF_NODE_ASSOC (SOURCE_NODE_ID);
CREATE INDEX FK_ALF_NASS_TNODE ON T_ALF_NODE_ASSOC (TARGET_NODE_ID);
CREATE INDEX FK_ALF_NASS_TQN ON T_ALF_NODE_ASSOC (TYPE_QNAME_ID);

INSERT INTO T_ALF_NODE_ASSOC ( ID, VERSION, SOURCE_NODE_ID, TARGET_NODE_ID, TYPE_QNAME_ID ) SELECT NA.ID, 1, NA.SOURCE_NODE_ID, NA.TARGET_NODE_ID, TQN.QNAME_ID FROM ALF_NODE_ASSOC NA JOIN T_QNAMES TQN ON (NA.TYPE_QNAME = TQN.QNAME);

-- Clean up
DROP TABLE ALF_NODE_ASSOC;
RENAME T_ALF_NODE_ASSOC TO ALF_NODE_ASSOC;
ALTER TABLE ALF_NODE_ASSOC ADD CONSTRAINT FK_ALF_NASS_TQN FOREIGN KEY (TYPE_QNAME_ID) REFERENCES ALF_QNAME (ID);

-- -----------------------------
-- Populate the Node Aspects --
-- -----------------------------
CREATE TABLE T_ALF_NODE_ASPECTS ( 
    NODE_ID BIGINT NOT NULL, 
    QNAME_ID BIGINT NOT NULL, 
    PRIMARY KEY (NODE_ID, QNAME_ID) 
);
CREATE INDEX FK_ALF_NASP_N ON T_ALF_NODE_ASPECTS (NODE_ID);
CREATE INDEX FK_ALF_NASP_QN ON T_ALF_NODE_ASPECTS (QNAME_ID);

-- Note the omission of sys:referencable.  This is implicit.
INSERT INTO T_ALF_NODE_ASPECTS ( NODE_ID, QNAME_ID ) SELECT NA.NODE_ID, TQN.QNAME_ID FROM ALF_NODE_ASPECTS NA JOIN T_QNAMES TQN ON (NA.QNAME = TQN.QNAME) WHERE TQN.QNAME != '{http://www.alfresco.org/model/system/1.0}referenceable';

-- Clean up
DROP TABLE ALF_NODE_ASPECTS;
RENAME T_ALF_NODE_ASPECTS TO ALF_NODE_ASPECTS;
ALTER TABLE ALF_NODE_ASPECTS ADD CONSTRAINT fk_alf_nasp_qn FOREIGN KEY (qname_id) REFERENCES alf_qname (id);

-- ---------------------------------
-- Populate the AVM Node Aspects --
-- ---------------------------------
CREATE TABLE T_AVM_ASPECTS ( 
    NODE_ID BIGINT NOT NULL, 
    QNAME_ID BIGINT NOT NULL, 
    PRIMARY KEY (NODE_ID, QNAME_ID) 
);

CREATE INDEX FK_AVM_NASP_N ON T_AVM_ASPECTS (NODE_ID);
CREATE INDEX FK_AVM_NASP_QN ON T_AVM_ASPECTS (QNAME_ID);
INSERT INTO T_AVM_ASPECTS ( NODE_ID, QNAME_ID ) SELECT  ASPECTS_OLD.NODE_ID,  TQN.QNAME_ID FROM AVM_ASPECTS ASPECTS_OLD JOIN T_QNAMES TQN ON (ASPECTS_OLD.QNAME = TQN.QNAME);
INSERT INTO T_AVM_ASPECTS ( NODE_ID, QNAME_ID ) SELECT ANEW.ID, TQN.QNAME_ID FROM AVM_ASPECTS_NEW ANEW JOIN T_QNAMES TQN ON (ANEW.NAME = TQN.QNAME)   LEFT JOIN AVM_ASPECTS AOLD ON (ANEW.ID = AOLD.NODE_ID AND ANEW.NAME = AOLD.QNAME)  WHERE  AOLD.ID IS NULL;
-- Clean up
DROP TABLE AVM_ASPECTS;
DROP TABLE AVM_ASPECTS_NEW;
RENAME T_AVM_ASPECTS TO AVM_ASPECTS;
ALTER TABLE AVM_ASPECTS ADD CONSTRAINT FK_AVM_NASP_N FOREIGN KEY (NODE_ID) REFERENCES AVM_NODES;
ALTER TABLE AVM_ASPECTS ADD CONSTRAINT FK_AVM_NASP_QN FOREIGN KEY (QNAME_ID) REFERENCES ALF_QNAME (ID);

-- ----------------------------------
-- Migrate Sundry Property Tables --
-- ----------------------------------

-- Create temporary mapping for property types
CREATE TABLE T_PROP_TYPES ( 
    TYPE_NAME VARCHAR(15) NOT NULL, 
    TYPE_ID INTEGER NOT NULL, 
    PRIMARY KEY (TYPE_NAME) 
);
INSERT INTO T_PROP_TYPES VALUES ('NULL', 0);
INSERT INTO T_PROP_TYPES VALUES ('BOOLEAN', 1);
INSERT INTO T_PROP_TYPES VALUES ('INTEGER', 2);
INSERT INTO T_PROP_TYPES VALUES ('LONG', 3);
INSERT INTO T_PROP_TYPES VALUES ('FLOAT', 4);
INSERT INTO T_PROP_TYPES VALUES ('DOUBLE', 5);
INSERT INTO T_PROP_TYPES VALUES ('STRING', 6);
INSERT INTO T_PROP_TYPES VALUES ('DATE', 7);
INSERT INTO T_PROP_TYPES VALUES ('DB_ATTRIBUTE', 8);
INSERT INTO T_PROP_TYPES VALUES ('SERIALIZABLE', 9);
INSERT INTO T_PROP_TYPES VALUES ('MLTEXT', 10);
INSERT INTO T_PROP_TYPES VALUES ('CONTENT', 11);
INSERT INTO T_PROP_TYPES VALUES ('NODEREF', 12);
INSERT INTO T_PROP_TYPES VALUES ('CHILD_ASSOC_REF', 13);
INSERT INTO T_PROP_TYPES VALUES ('ASSOC_REF', 14);
INSERT INTO T_PROP_TYPES VALUES ('QNAME', 15);
INSERT INTO T_PROP_TYPES VALUES ('PATH', 16);
INSERT INTO T_PROP_TYPES VALUES ('LOCALE', 17);
INSERT INTO T_PROP_TYPES VALUES ('VERSION_NUMBER', 18);

-- Modify the avm_store_properties table
--ASSIGN:asp_max_id=next_val
select case when max(id) is not null then max(id)+1 else 1 end as next_val from AVM_STORE_PROPERTIES;

CREATE TABLE T_AVM_STORE_PROPERTIES ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY (start with ${asp_max_id}), 
    AVM_STORE_ID BIGINT, 
    QNAME_ID BIGINT NOT NULL, 
    ACTUAL_TYPE_N INTEGER NOT NULL, 
    PERSISTED_TYPE_N INTEGER NOT NULL, 
    MULTI_VALUED SMALLINT NOT NULL, 
    BOOLEAN_VALUE SMALLINT, 
    LONG_VALUE BIGINT, 
    FLOAT_VALUE FLOAT, 
    DOUBLE_VALUE DOUBLE, 
    STRING_VALUE VARCHAR(1024), 
    SERIALIZABLE_VALUE VARCHAR(16384) FOR BIT DATA, 
    PRIMARY KEY (ID) 
);
CREATE INDEX FK_AVM_SPROP_QNAME ON T_AVM_STORE_PROPERTIES (QNAME_ID);
CREATE INDEX FK_AVM_SPROP_STORE ON T_AVM_STORE_PROPERTIES (AVM_STORE_ID);

INSERT INTO T_AVM_STORE_PROPERTIES ( ID, AVM_STORE_ID, QNAME_ID, ACTUAL_TYPE_N, PERSISTED_TYPE_N, MULTI_VALUED, BOOLEAN_VALUE, LONG_VALUE, FLOAT_VALUE, DOUBLE_VALUE, STRING_VALUE, SERIALIZABLE_VALUE )  SELECT P.ID, P.AVM_STORE_ID, TQN.QNAME_ID, PTYPES_ACTUAL.TYPE_ID, PTYPES_PERSISTED.TYPE_ID,      P.MULTI_VALUED, P.BOOLEAN_VALUE, P.LONG_VALUE, P.FLOAT_VALUE, P.DOUBLE_VALUE, P.STRING_VALUE, P.SERIALIZABLE_VALUE  FROM  AVM_STORE_PROPERTIES P   JOIN T_QNAMES TQN ON (P.QNAME = TQN.QNAME) JOIN T_PROP_TYPES PTYPES_ACTUAL ON (PTYPES_ACTUAL.TYPE_NAME = P.ACTUAL_TYPE) JOIN T_PROP_TYPES PTYPES_PERSISTED ON (PTYPES_PERSISTED.TYPE_NAME = P.PERSISTED_TYPE);

DROP TABLE AVM_STORE_PROPERTIES;
RENAME T_AVM_STORE_PROPERTIES TO AVM_STORE_PROPERTIES;
ALTER TABLE AVM_STORE_PROPERTIES ADD CONSTRAINT FK_AVM_SPROP_QNAME FOREIGN KEY (QNAME_ID) REFERENCES ALF_QNAME (ID);
ALTER TABLE AVM_STORE_PROPERTIES ADD CONSTRAINT FK_AVM_SPROP_STORE FOREIGN KEY (AVM_STORE_ID) REFERENCES AVM_STORES;

-- Modify the avm_node_properties_new table
CREATE TABLE T_AVM_NODE_PROPERTIES ( 
    NODE_ID BIGINT NOT NULL, 
    ACTUAL_TYPE_N INTEGER NOT NULL, 
    PERSISTED_TYPE_N INTEGER NOT NULL, 
    MULTI_VALUED SMALLINT NOT NULL, 
    BOOLEAN_VALUE SMALLINT, 
    LONG_VALUE BIGINT, 
    FLOAT_VALUE FLOAT, 
    DOUBLE_VALUE DOUBLE, 
    STRING_VALUE VARCHAR(1024), 
    SERIALIZABLE_VALUE VARCHAR(16384) FOR BIT DATA, 
    QNAME_ID BIGINT NOT NULL, 
    PRIMARY KEY (NODE_ID, QNAME_ID) 
);
CREATE INDEX FK_AVM_NPROP_N ON T_AVM_NODE_PROPERTIES (NODE_ID);
CREATE INDEX FK_AVM_NPROP_QN ON T_AVM_NODE_PROPERTIES (QNAME_ID);

INSERT INTO T_AVM_NODE_PROPERTIES ( NODE_ID, QNAME_ID, ACTUAL_TYPE_N, PERSISTED_TYPE_N, MULTI_VALUED, BOOLEAN_VALUE, LONG_VALUE, FLOAT_VALUE, DOUBLE_VALUE, STRING_VALUE, SERIALIZABLE_VALUE ) SELECT P.NODE_ID, TQN.QNAME_ID, PTYPES_ACTUAL.TYPE_ID, PTYPES_PERSISTED.TYPE_ID, P.MULTI_VALUED, P.BOOLEAN_VALUE, P.LONG_VALUE, P.FLOAT_VALUE, P.DOUBLE_VALUE, P.STRING_VALUE, P.SERIALIZABLE_VALUE FROM AVM_NODE_PROPERTIES_NEW P JOIN T_QNAMES TQN ON (P.QNAME = TQN.QNAME) JOIN T_PROP_TYPES PTYPES_ACTUAL ON (PTYPES_ACTUAL.TYPE_NAME = P.ACTUAL_TYPE) JOIN T_PROP_TYPES PTYPES_PERSISTED ON (PTYPES_PERSISTED.TYPE_NAME = P.PERSISTED_TYPE);
INSERT INTO T_AVM_NODE_PROPERTIES ( NODE_ID, QNAME_ID, ACTUAL_TYPE_N, PERSISTED_TYPE_N, MULTI_VALUED, BOOLEAN_VALUE, LONG_VALUE, FLOAT_VALUE, DOUBLE_VALUE, STRING_VALUE, SERIALIZABLE_VALUE ) SELECT  P.NODE_ID, TQN.QNAME_ID, PTYPES_ACTUAL.TYPE_ID, PTYPES_PERSISTED.TYPE_ID, P.MULTI_VALUED, P.BOOLEAN_VALUE, P.LONG_VALUE, P.FLOAT_VALUE, P.DOUBLE_VALUE, P.STRING_VALUE, P.SERIALIZABLE_VALUE FROM AVM_NODE_PROPERTIES P JOIN T_QNAMES TQN ON (P.QNAME = TQN.QNAME) JOIN T_PROP_TYPES PTYPES_ACTUAL ON (PTYPES_ACTUAL.TYPE_NAME = P.ACTUAL_TYPE) JOIN T_PROP_TYPES PTYPES_PERSISTED ON (PTYPES_PERSISTED.TYPE_NAME = P.PERSISTED_TYPE) LEFT OUTER JOIN T_AVM_NODE_PROPERTIES TANP ON (TQN.QNAME_ID = TANP.QNAME_ID) WHERE TANP.QNAME_ID IS NULL;

DROP TABLE AVM_NODE_PROPERTIES;
DROP TABLE AVM_NODE_PROPERTIES_NEW;
RENAME T_AVM_NODE_PROPERTIES TO AVM_NODE_PROPERTIES;
ALTER TABLE AVM_NODE_PROPERTIES ADD CONSTRAINT FK_AVM_NPROP_N FOREIGN KEY (NODE_ID) REFERENCES AVM_NODES;
ALTER TABLE AVM_NODE_PROPERTIES ADD CONSTRAINT FK_AVM_NPROP_QN FOREIGN KEY (QNAME_ID) REFERENCES ALF_QNAME (ID);

-- -----------------
-- Build Locales --
-- -----------------
CREATE TABLE ALF_LOCALE ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 2), 
    VERSION BIGINT NOT NULL DEFAULT 1, 
    LOCALE_STR VARCHAR(20) NOT NULL, 
    PRIMARY KEY (ID), 
    UNIQUE (LOCALE_STR) 
);
INSERT INTO ALF_LOCALE (ID, LOCALE_STR) VALUES (1, '.default');
-- Locales come from the attribute table which was used to support MLText persistence
INSERT INTO alf_locale (locale_str)
   SELECT DISTINCT(ma.mkey)
      FROM alf_node_properties np
      JOIN alf_attributes a1 ON (np.attribute_value = a1.id)
      JOIN alf_map_attribute_entries ma ON (ma.map_id = a1.id)
;

-- -------------------------------
-- Migrate ADM Property Tables --
-- -------------------------------
CREATE TABLE T_ALF_NODE_PROPERTIES ( 
    NODE_ID BIGINT NOT NULL, 
    ACTUAL_TYPE_N INTEGER NOT NULL, 
    PERSISTED_TYPE_N INTEGER NOT NULL, 
    BOOLEAN_VALUE SMALLINT, 
    LONG_VALUE BIGINT, 
    FLOAT_VALUE FLOAT, 
    DOUBLE_VALUE DOUBLE, 
    STRING_VALUE VARCHAR(1024), 
    SERIALIZABLE_VALUE VARCHAR(16384) FOR BIT DATA, 
    QNAME_ID BIGINT NOT NULL, 
    LIST_INDEX INTEGER NOT NULL, 
    LOCALE_ID BIGINT NOT NULL, 
    PRIMARY KEY (NODE_ID, QNAME_ID, LIST_INDEX, LOCALE_ID) 
);
CREATE INDEX FK_ALF_NPROP_LOC ON T_ALF_NODE_PROPERTIES (LOCALE_ID);
CREATE INDEX FK_ALF_NPROP_N ON T_ALF_NODE_PROPERTIES (NODE_ID);
CREATE INDEX FK_ALF_NPROP_QN ON T_ALF_NODE_PROPERTIES (QNAME_ID);

-- Copy values over
INSERT INTO T_ALF_NODE_PROPERTIES ( NODE_ID, QNAME_ID, LOCALE_ID, LIST_INDEX, ACTUAL_TYPE_N, PERSISTED_TYPE_N, BOOLEAN_VALUE, LONG_VALUE, FLOAT_VALUE, DOUBLE_VALUE, STRING_VALUE, SERIALIZABLE_VALUE ) SELECT NP.NODE_ID, TQN.QNAME_ID, 1, -1, PTYPES_ACTUAL.TYPE_ID, PTYPES_PERSISTED.TYPE_ID, NP.BOOLEAN_VALUE, NP.LONG_VALUE, NP.FLOAT_VALUE, NP.DOUBLE_VALUE, NP.STRING_VALUE, NP.SERIALIZABLE_VALUE FROM ALF_NODE_PROPERTIES NP JOIN T_QNAMES TQN ON (NP.QNAME = TQN.QNAME) JOIN T_PROP_TYPES PTYPES_ACTUAL ON (PTYPES_ACTUAL.TYPE_NAME = NP.ACTUAL_TYPE) JOIN T_PROP_TYPES PTYPES_PERSISTED ON (PTYPES_PERSISTED.TYPE_NAME = NP.PERSISTED_TYPE) WHERE NP.ATTRIBUTE_VALUE IS NULL;
UPDATE T_ALF_NODE N SET AUDIT_CREATOR = ( SELECT STRING_VALUE FROM T_ALF_NODE_PROPERTIES NP JOIN ALF_QNAME QN ON (NP.QNAME_ID = QN.ID) JOIN ALF_NAMESPACE NS ON (QN.NS_ID = NS.ID) WHERE NP.NODE_ID = N.ID AND NS.URI = 'FILLER-http://www.alfresco.org/model/content/1.0' AND QN.LOCAL_NAME = 'creator');
UPDATE T_ALF_NODE N SET AUDIT_CREATED =(SELECT STRING_VALUE FROM T_ALF_NODE_PROPERTIES NP JOIN ALF_QNAME QN ON (NP.QNAME_ID = QN.ID) JOIN ALF_NAMESPACE NS ON (QN.NS_ID = NS.ID) WHERE NP.NODE_ID = N.ID AND NS.URI = 'FILLER-http://www.alfresco.org/model/content/1.0' AND      QN.LOCAL_NAME = 'created');
UPDATE T_ALF_NODE N SET AUDIT_MODIFIER =( SELECT STRING_VALUE FROM T_ALF_NODE_PROPERTIES NP JOIN ALF_QNAME QN ON (NP.QNAME_ID = QN.ID) JOIN ALF_NAMESPACE NS ON (QN.NS_ID = NS.ID)  WHERE NP.NODE_ID = N.ID AND NS.URI = 'FILLER-http://www.alfresco.org/model/content/1.0' AND QN.LOCAL_NAME = 'modifier');
UPDATE T_ALF_NODE N SET AUDIT_MODIFIED =( SELECT STRING_VALUE FROM T_ALF_NODE_PROPERTIES NP JOIN ALF_QNAME QN ON (NP.QNAME_ID = QN.ID) JOIN ALF_NAMESPACE NS ON (QN.NS_ID = NS.ID)  WHERE NP.NODE_ID = N.ID AND NS.URI = 'FILLER-http://www.alfresco.org/model/content/1.0' AND QN.LOCAL_NAME = 'modified');
DELETE FROM T_ALF_NODE_PROPERTIES WHERE T_ALF_NODE_PROPERTIES.QNAME_ID IN (SELECT ID FROM ALF_QNAME WHERE ALF_QNAME.NS_ID = (SELECT ID FROM ALF_NAMESPACE WHERE URI = 'FILLER-http://www.alfresco.org/model/content/1.0') AND ALF_QNAME.LOCAL_NAME IN ('creator', 'created', 'modifier', 'modified'));
INSERT INTO T_ALF_NODE_PROPERTIES ( NODE_ID, QNAME_ID, LOCALE_ID, LIST_INDEX, ACTUAL_TYPE_N, PERSISTED_TYPE_N, BOOLEAN_VALUE, LONG_VALUE, FLOAT_VALUE, DOUBLE_VALUE,  STRING_VALUE, SERIALIZABLE_VALUE ) SELECT NP.NODE_ID, TQN.QNAME_ID, LOC.ID, -1, -1, 0, 0, 0, 0, 0, A2.STRING_VALUE, A2.SERIALIZABLE_VALUE FROM ALF_NODE_PROPERTIES NP JOIN T_QNAMES TQN ON (NP.QNAME = TQN.QNAME) JOIN ALF_ATTRIBUTES A1 ON (NP.ATTRIBUTE_VALUE = A1.ID) JOIN ALF_MAP_ATTRIBUTE_ENTRIES MA ON (MA.MAP_ID = A1.ID) JOIN ALF_LOCALE LOC ON (MA.MKEY = LOC.LOCALE_STR) JOIN ALF_ATTRIBUTES A2 ON (MA.ATTRIBUTE_ID = A2.ID); 
UPDATE T_ALF_NODE_PROPERTIES SET ACTUAL_TYPE_N = 6, PERSISTED_TYPE_N = 6, SERIALIZABLE_VALUE = NULL  WHERE ACTUAL_TYPE_N = -1 AND STRING_VALUE IS NOT NULL;
UPDATE T_ALF_NODE_PROPERTIES  SET ACTUAL_TYPE_N = 9, PERSISTED_TYPE_N = 9  WHERE ACTUAL_TYPE_N = -1 AND SERIALIZABLE_VALUE IS NOT NULL;
DELETE FROM T_ALF_NODE_PROPERTIES WHERE ACTUAL_TYPE_N = -1;
DROP TABLE ALF_NODE_PROPERTIES;
RENAME T_ALF_NODE_PROPERTIES TO ALF_NODE_PROPERTIES;
ALTER TABLE ALF_NODE_PROPERTIES ADD CONSTRAINT FK_ALF_NPROP_LOC FOREIGN KEY (LOCALE_ID) REFERENCES ALF_LOCALE (ID);
ALTER TABLE ALF_NODE_PROPERTIES ADD CONSTRAINT FK_ALF_NPROP_QN FOREIGN KEY (QNAME_ID) REFERENCES ALF_QNAME (ID);

CREATE TABLE T_DEL_ATTRIBUTES (ID BIGINT NOT NULL, PRIMARY KEY (ID));
INSERT INTO T_DEL_ATTRIBUTES (SELECT ID FROM ALF_ATTRIBUTES WHERE TYPE = 'M');
DELETE FROM T_DEL_ATTRIBUTES WHERE EXISTS(SELECT 1 FROM ALF_MAP_ATTRIBUTE_ENTRIES AS MA WHERE MA.ATTRIBUTE_ID = T_DEL_ATTRIBUTES.ID);
DELETE FROM T_DEL_ATTRIBUTES WHERE EXISTS(SELECT 1 FROM ALF_LIST_ATTRIBUTE_ENTRIES AS LA WHERE LA.ATTRIBUTE_ID = T_DEL_ATTRIBUTES.ID);
DELETE FROM T_DEL_ATTRIBUTES WHERE EXISTS(SELECT 1 FROM ALF_GLOBAL_ATTRIBUTES AS GA WHERE GA.ATTRIBUTE = T_DEL_ATTRIBUTES.ID);
INSERT INTO T_DEL_ATTRIBUTES (SELECT A.ID FROM T_DEL_ATTRIBUTES AS T JOIN ALF_MAP_ATTRIBUTE_ENTRIES AS MA ON (MA.MAP_ID = T.ID) JOIN ALF_ATTRIBUTES AS A ON (MA.ATTRIBUTE_ID = A.ID));
DELETE FROM ALF_MAP_ATTRIBUTE_ENTRIES WHERE EXISTS(SELECT 1 FROM T_DEL_ATTRIBUTES AS T WHERE ALF_MAP_ATTRIBUTE_ENTRIES.MAP_ID = T.ID);
DELETE FROM alf_list_attribute_entries WHERE EXISTS(SELECT 1 FROM T_DEL_ATTRIBUTES AS T WHERE alf_list_attribute_entries.list_id = T.ID);
DELETE FROM ALF_ATTRIBUTES WHERE EXISTS(SELECT 1 FROM T_DEL_ATTRIBUTES AS T WHERE ALF_ATTRIBUTES.ID = T.ID);
DROP TABLE T_DEL_ATTRIBUTES;

-- ---------------------------------------------------
-- Remove the FILLER- values from the namespace uri --
-- ---------------------------------------------------
UPDATE ALF_NAMESPACE SET URI = '.empty' WHERE URI = 'FILLER-';
UPDATE ALF_NAMESPACE SET URI = SUBSTR(URI, 8) WHERE URI LIKE 'FILLER-%';

-- ------------------
-- Final clean up --
-- ------------------
DROP TABLE T_QNAMES;
DROP TABLE T_PROP_TYPES;
DROP TABLE ALF_NODE_STATUS;
DROP TABLE ALF_NODE;
RENAME T_ALF_NODE TO ALF_NODE;


-- -------------------------------------
-- Modify index and constraint names --
-- -------------------------------------
--alf_attributes
DROP INDEX fk_attributes_n_acl;  -- (optional)
ALTER TABLE alf_attributes DROP FOREIGN KEY fk_attributes_n_acl;  -- (optional)
DROP INDEX fk_attr_n_acl;  -- (optional)
ALTER TABLE alf_attributes DROP FOREIGN KEY fk_attr_n_acl;  -- (optional)
CREATE INDEX fk_alf_attr_acl ON alf_attributes (acl_id);
ALTER TABLE ALF_ATTRIBUTES ADD CONSTRAINT FK_ALF_ATTR_ACL FOREIGN KEY (ACL_ID) REFERENCES ALF_ACCESS_CONTROL_LIST;

--alf_global_attributes
ALTER TABLE alf_global_attributes DROP FOREIGN KEY FK64D0B9CF69B9F16A; -- (optional)
DROP INDEX FK64D0B9CF69B9F16A; -- (optional)
create index fk_alf_gatt_att on alf_global_attributes (attribute);
alter table alf_global_attributes add constraint fk_alf_gatt_att foreign key (attribute) references alf_attributes;

--alf_list_attribute_entries
ALTER TABLE alf_list_attribute_entries DROP FOREIGN KEY FKC7D52FB02C5AB86C; -- (optional)
ALTER TABLE alf_list_attribute_entries DROP FOREIGN KEY FKC7D52FB0ACD8822C; -- (optional)
DROP INDEX FKC7D52FB02C5AB86C; -- (optional)
DROP INDEX FKC7D52FB0ACD8822C; -- (optional)
create index fk_alf_lent_latt on alf_list_attribute_entries (list_id);
alter table alf_list_attribute_entries add constraint fk_alf_lent_latt foreign key (list_id) references alf_attributes;
create index fk_alf_lent_att on alf_list_attribute_entries (attribute_id);
alter table alf_list_attribute_entries add constraint fk_alf_lent_att foreign key (attribute_id) references alf_attributes;

--alf_map_attribute_entries
DROP INDEX FK335CAE26AEAC208C; -- (optional)
DROP INDEX FK335CAE262C5AB86C; -- (optional)
ALTER TABLE alf_map_attribute_entries DROP FOREIGN KEY FK335CAE262C5AB86C; -- (optional)
ALTER TABLE alf_map_attribute_entries DROP FOREIGN KEY FK335CAE26AEAC208C; -- (optional)
create index fk_alf_matt_att on alf_map_attribute_entries (attribute_id);
alter table alf_map_attribute_entries add constraint fk_alf_matt_att foreign key (attribute_id) references alf_attributes;
create index fk_alf_matt_matt on alf_map_attribute_entries (map_id);
alter table alf_map_attribute_entries add constraint fk_alf_matt_matt foreign key (map_id) references alf_attributes;

--alf_transaction
DROP INDEX idx_commit_time_ms; -- (optional)
DROP INDEX FKB8761A3A9AE340B7;
ALTER TABLE alf_transaction DROP FOREIGN KEY FKB8761A3A9AE340B7; -- (optional)
create index fk_alf_txn_svr on alf_transaction (server_id);
alter table alf_transaction add constraint fk_alf_txn_svr foreign key (server_id) references alf_server;
create index idx_alf_txn_ctms on alf_transaction (commit_time_ms);

--avm_child_entries
DROP INDEX fk_avm_ce_child; -- (optional)
alter table avm_child_entries DROP FOREIGN KEY fk_avm_ce_child; -- (optional)
DROP INDEX fk_avm_ce_parent; -- (optional)
alter table avm_child_entries DROP FOREIGN KEY fk_avm_ce_parent; -- (optional)
create index fk_avm_ce_child on avm_child_entries (child_id); 
alter table avm_child_entries ADD CONSTRAINT fk_avm_ce_child FOREIGN KEY (child_id) REFERENCES avm_nodes (id);
create index fk_avm_ce_parent on avm_child_entries (parent_id);
alter table avm_child_entries ADD CONSTRAINT fk_avm_ce_parent FOREIGN KEY (parent_id) REFERENCES avm_nodes (id);

--avm_history_links
DROP INDEX fk_avm_hl_desc; -- (optional)
DROP INDEX fk_avm_hl_ancestor; -- (optional)
DROP INDEX idx_avm_hl_revpk; -- (optional)
alter table avm_history_links DROP FOREIGN KEY fk_avm_hl_desc; -- (optional)
alter table avm_history_links DROP FOREIGN KEY fk_avm_hl_ancestor; -- (optional)
create index fk_avm_hl_desc on avm_history_links (descendent);
alter table avm_history_links ADD CONSTRAINT fk_avm_hl_desc FOREIGN KEY (descendent) REFERENCES avm_nodes (id);
create index fk_avm_hl_ancestor on avm_history_links (ancestor);
alter table avm_history_links ADD CONSTRAINT fk_avm_hl_ancestor FOREIGN KEY (ancestor) REFERENCES avm_nodes (id);
create index idx_avm_hl_revpk on avm_history_links (descendent, ancestor);

--avm_merge_links
DROP INDEX fk_avm_ml_to; -- (optional)
DROP INDEX fk_avm_ml_from; -- (optional)
ALTER TABLE avm_merge_links DROP FOREIGN KEY fk_avm_ml_to; -- (optional)
ALTER TABLE avm_merge_links DROP FOREIGN KEY fk_avm_ml_from; -- (optional)
create index fk_avm_ml_to on avm_merge_links (mto);
ALTER TABLE avm_merge_links ADD CONSTRAINT fk_avm_ml_to FOREIGN KEY (mto) REFERENCES avm_nodes (id);
create index fk_avm_ml_from on avm_merge_links (mfrom);
ALTER TABLE avm_merge_links ADD CONSTRAINT fk_avm_ml_from FOREIGN KEY (mfrom) REFERENCES avm_nodes (id);

--avm_nodes
DROP INDEX fk_avm_n_acl; -- (optional)
DROP INDEX fk_avm_n_store; -- (optional)
DROP INDEX idx_avm_n_pi; -- (optional)
ALTER TABLE avm_nodes DROP FOREIGN KEY fk_avm_n_acl; -- (optional)
ALTER TABLE avm_nodes DROP FOREIGN KEY fk_avm_n_store; -- (optional)
create index fk_avm_n_acl on avm_nodes (acl_id); 
ALTER TABLE avm_nodes ADD CONSTRAINT fk_avm_n_acl FOREIGN KEY (acl_id) REFERENCES alf_access_control_list (id);
create index fk_avm_n_store on avm_nodes (store_new_id);
ALTER TABLE avm_nodes ADD CONSTRAINT fk_avm_n_store FOREIGN KEY (store_new_id) REFERENCES avm_stores (id);
create index idx_avm_n_pi on avm_nodes (primary_indirection);

--avm_stores
DROP INDEX fk_avm_s_root; -- (optional)
ALTER TABLE avm_stores DROP FOREIGN KEY fk_avm_s_root; -- (optional)
create index fk_avm_s_acl on avm_stores (acl_id);
ALTER TABLE avm_stores ADD CONSTRAINT fk_avm_s_acl FOREIGN KEY (acl_id) REFERENCES alf_access_control_list (id);
create index fk_avm_s_root on avm_stores (current_root_id);
ALTER TABLE avm_stores ADD CONSTRAINT fk_avm_s_root FOREIGN KEY (current_root_id) REFERENCES avm_nodes (id);

--avm_version_layered_node_entry
DROP INDEX FK182E672DEB9D70C; -- (optional)
ALTER TABLE avm_version_layered_node_entry DROP FOREIGN KEY FK182E672DEB9D70C; -- (optional)
create index fk_avm_vlne_vr on avm_version_layered_node_entry (version_root_id);
alter table avm_version_layered_node_entry add constraint fk_avm_vlne_vr foreign key (version_root_id) references avm_version_roots;

--avm_version_roots
DROP INDEX idx_avm_vr_version; -- (optional)
DROP INDEX idx_avm_vr_revuq; -- (optional)
DROP INDEX fk_avm_vr_root; -- (optional)
DROP INDEX fk_avm_vr_store; -- (optional)
ALTER TABLE avm_version_roots DROP FOREIGN KEY fk_avm_vr_root; -- (optional)
ALTER TABLE avm_version_roots DROP FOREIGN KEY fk_avm_vr_store; -- (optional)
create index fk_avm_vr_store on avm_version_roots (avm_store_id);
ALTER TABLE avm_version_roots ADD CONSTRAINT fk_avm_vr_store FOREIGN KEY (avm_store_id) REFERENCES avm_stores (id);
create index fk_avm_vr_root on avm_version_roots (root_id);
ALTER TABLE avm_version_roots ADD CONSTRAINT fk_avm_vr_root FOREIGN KEY (root_id) REFERENCES avm_nodes (id);
create index idx_avm_vr_version on avm_version_roots (version_id);
create index idx_avm_vr_revuq on avm_version_roots (avm_store_id, version_id);

--ALF_NODE
ALTER TABLE ALF_NODE ADD CONSTRAINT FK_ALF_NODE_TXN FOREIGN KEY (TRANSACTION_ID) REFERENCES ALF_TRANSACTION;
ALTER TABLE ALF_NODE ADD CONSTRAINT FK_ALF_NODE_ACL FOREIGN KEY (ACL_ID) REFERENCES ALF_ACCESS_CONTROL_LIST;
ALTER TABLE ALF_NODE ADD CONSTRAINT FK_ALF_NODE_STORE FOREIGN KEY (STORE_ID) REFERENCES ALF_STORE;
ALTER TABLE ALF_NODE ADD CONSTRAINT FK_ALF_NODE_TQN FOREIGN KEY (TYPE_QNAME_ID) REFERENCES ALF_QNAME (ID);

alter table alf_child_assoc add constraint fk_alf_cass_cnode foreign key (child_node_id) references alf_node;
alter table alf_child_assoc add constraint fk_alf_cass_pnode foreign key (parent_node_id) references alf_node;
alter table alf_node_aspects add constraint fk_alf_nasp_n foreign key (node_id) references alf_node;
alter table alf_node_assoc add constraint fk_alf_nass_snode foreign key (source_node_id) references alf_node;
alter table alf_node_assoc add constraint fk_alf_nass_tnode foreign key (target_node_id) references alf_node;
alter table alf_node_properties add constraint fk_alf_nprop_n foreign key (node_id) references alf_node;
alter table alf_store add constraint fk_alf_store_root foreign key (root_node_id) references alf_node;
--
-- Record script finish
--
DELETE FROM alf_applied_patch WHERE id = 'patch.db-V2.2-Upgrade-From-2.1';
INSERT INTO alf_applied_patch
  (id, description, fixes_from_schema, fixes_to_schema, applied_to_schema, target_schema, applied_on_date, applied_to_server, was_executed, succeeded, report)
  VALUES
  (
    'patch.db-V2.2-Upgrade-From-2.1', 'Manually executed script upgrade V2.2: Upgrade from 2.1',
    0, 85, -1, 91, null, 'UNKNOWN', ${TRUE}, ${TRUE}, 'Script completed'
  );